/*  $Date: 2015/10/12 $  $Revision: #53 $
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2016 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

// Reference paper:
// http://graphics.pixar.com/library/StatFrameworkForImportance/paper.pdf

#include "RixLight.h"
#include "RixShadingUtils.h"
#include "RixPhotonGuiding.h"
#include "RixColorTemperature.h"
#include <cstdio>
#include <QImage>
#include <QColor>
#include <math.h>

struct LightBasis
{
    RtPoint3    position;
    RtVector3   Un;
    RtVector3   Vn;
    RtVector3   Nn;
    RtVector3   uExtent;
    RtVector3   vExtent;
    RtFloat     width;
    RtFloat     height;
    RtFloat     area;
    RtMatrix4x4 xform;
    RtMatrix4x4 invXform;

    LightBasis(){};
    LightBasis(RtMatrix4x4 const& _xform)
    {
        Init(_xform);
    };

    void Init(RtMatrix4x4 const& _xform)
    {
        // this describes local to current space at shutter open
        xform = _xform;
        xform.Inverse(&invXform);

        Un = *(RtVector3*)&xform[0];
        Vn = *(RtVector3*)&xform[4];
        Nn = *(RtVector3*)&xform[8];
        position = *(RtPoint3*)&xform[12];

        width = Un.Length();
        height = Vn.Length();
        area = width * height;

        uExtent = Un;
        vExtent = Vn;
        Un.Normalize(); 
        Vn.Normalize(); 
        Nn.Normalize();
    }
};

float lerp(float a, float b, float f)
{
    return a + f * (b - a);
}

RtFloat3 lerp(RtFloat3 a, RtFloat3 b, float f)
{
    return RtFloat3(lerp(a.x,b.x,f),lerp(a.y,b.y,f),lerp(a.z,b.z,f));
}

template <class T> const T& min (const T& a, const T& b) {
  return !(b<a)?a:b;     // or: return !comp(b,a)?a:b; for version (2)
}

template <class T> const T& max (const T& a, const T& b) {
  return (a<b)?b:a;     // or: return comp(a,b)?b:a; for version (2)
}

float clamp(float x, float lower, float upper)
{
    return min(upper, max(x, lower));
}

RtFloat2 clamp(RtFloat2 x, RtFloat2 lower, RtFloat2 upper)
{
    return RtFloat2(clamp(x.x,lower.x,upper.x),clamp(x.y,lower.y,upper.y));
}

RtFloat3 clamp(RtFloat3 x, RtFloat3 lower, RtFloat3 upper)
{
    return RtFloat3(clamp(x.x,lower.x,upper.x),clamp(x.y,lower.y,upper.y),clamp(x.z,lower.z,upper.z));
}

class PxrSimpleRectLight : public RixLight
{
public:

    PxrSimpleRectLight(
        RixLightFactory const* factory,
        Type type,
        RtFloat exposure,
        RtFloat intensity, 
        RtColorRGB color,
        QImage colorMap,
        RtConstString lightGroup,
        RtInt sides,
        bool useEquiangularSampling);

    ~PxrSimpleRectLight()
    {
    }

    virtual RixSCDetail GetProperty(LightProperty property,
                                    void const** result) const;

    virtual void GetBounds(RtInt& nPoints, RtPoint3 const *& points) const;
    virtual bool Intersect(
        bool isTransmissionRay,
        RtMatrix4x4 const& currentToLocal,
        RtMatrix4x4 const& localToCurrent,
        RtFloat const rayTime, 
        RtPoint3 const& rayOrigin, 
        RtVector3 const& rayDirection, 
        // outputs - put these in a struct
        RtFloat& hitDistance, // input too
        RtFloat& u, 
        RtFloat& v,
        RtFloat& w,
        RtPoint3& hitP,
        RtPoint3& hitNn) const;

    virtual RtFloat GetPower() const;
    virtual RtFloat GetSolidAngleEstimate(
        RtInt nPoints,
        RtPoint3 const* pP,
        RtVector3 const* pN,
        RtFloat* pOutSolidAngles) const;
    virtual RtFloat GetIncidentRadianceEstimate(
        RtPoint3 const& segmentOrigin,
        RtVector3 const& segmentDir,
        RtFloat segmentLen,
        RtMatrix4x4 const& lightToCurrent,
        RtMatrix4x4 const& currentToLight,
        RtFloat& minT,
        RtFloat& maxT) const; 
    virtual RtFloat GetIncidentRadianceEstimate(
        RtPoint3 const& P,
        RtMatrix4x4 const& lightToCurrent,
        RtMatrix4x4 const& currentToLight) const;
    virtual RtFloat GetPowerEstimate(RtMatrix4x4 const& xform) const;

    void GenerateSamples(
        RixLightContext const& qc, 
        RixScatterPoint const& scatter, 
        GenerateSamplesResults& qr) const;
    void EvaluateSamples(
        RixLightContext const& qc, 
        RixSamplePoint const& sample, 
        RixScatterPoint const& scatter, 
        EvaluateSamplesResults& qr) const;
    void GenerateEmission(
        RixLightContext const& qc, 
        GenerateEmissionResults& qr) const;
    void EvaluateEmissionForCamera(
        RixLightContext const& qc,
        RixSamplePoint const& sample,
        RixScatterPoint const& scatter,
        EvaluateEmissionForCameraResults& results) const;
    RixLight* Edit(
        RixContext& ctx,
        RixParameterList const* pList,
        RtConstPointer instanceData);
    
    RtConstString GetLightGroupName() const {return m_lightGroup;}
    RtColorRGB getColorMapValue(RtFloat2 _uv) const;
    RtFloat3 getPixelValue(RtFloat2 _x) const;

private:
    RtPoint3    m_bounds[4];
    RtFloat     m_intensity;
    RtColorRGB  m_color;
    RtFloat     m_meanTexVal;
    QImage      m_colorMap;
    RtConstString const m_lightGroup;
    RtInt m_sides;

    bool m_useEquiangularSampling;

};

PxrSimpleRectLight::PxrSimpleRectLight(
    RixLightFactory const* factory,
    Type type,
    RtFloat exposure,
    RtFloat intensity, 
    RtColorRGB color,
    QImage colorMap,
    RtConstString lightGroup,
    RtInt sides,
    bool useEquiangularSampling)
    : RixLight(factory, type)
    , m_intensity(intensity)
    , m_color(color)
    , m_colorMap(colorMap)
    , m_lightGroup(lightGroup)
    , m_sides(sides)
    , m_useEquiangularSampling(useEquiangularSampling)
{
    // intersection happens in local space: bounds expressed in local space
    m_bounds[0] = RtPoint3(-.5f,-.5f,0);
    m_bounds[1] = RtPoint3(-.5f, .5f,0);
    m_bounds[2] = RtPoint3( .5f, .5f,0);
    m_bounds[3] = RtPoint3( .5f,-.5f,0);

    m_intensity *= powf(2.0f, exposure);

    m_meanTexVal = 1.0f; 
}

RixSCDetail PxrSimpleRectLight::GetProperty(LightProperty property,
                        void const** result) const
{
    if (RixLight::k_LightGroupName == property)
    {
        (*result) = m_lightGroup;
        return k_RixSCUniform;
    }
    return RixLight::GetProperty(property, result);
}

void
PxrSimpleRectLight::GetBounds(RtInt& nPoints, RtPoint3 const *& points) const
{
    nPoints = 4;
    points = m_bounds;
}

bool
PxrSimpleRectLight::Intersect(
    bool isTransmissionRay,
    RtMatrix4x4 const& _currentToLocal,
    RtMatrix4x4 const& _localToCurrent,
    RtFloat const rayTime,
    RtPoint3 const& rayOrigin, 
    RtVector3 const& rayDirection, 
    // outputs - put these in a struct
    RtFloat& hitDistance, 
    RtFloat& u, 
    RtFloat& v,
    RtFloat& w,
    RtPoint3& hitP,
    RtNormal3& hitNn) const
{
    RtFloat maxHitDistance = hitDistance;
    if (isTransmissionRay)
    {
        maxHitDistance -= 0.01f;
    }

    RtMatrix4x4 const* localToCurrent = &_localToCurrent;
    RtMatrix4x4 const* currentToLocal = &_currentToLocal;

    RtPoint3 localRayOrigin = currentToLocal->pTransform(rayOrigin);
    RtVector3 localRayDirection = currentToLocal->vTransform(rayDirection);
    localRayDirection.Normalize();

    // Ro: rayOrigin, Rd: rayDirection
    // Ray: P = Ro + tRd
    // Plane: P dot N + d = 0
    // N = <0,0,1>
    // d = 0
    //
    // t = -(Ro dot N + d) / (Rd dot N)
    //
    // substitute N = <0,0,1>, d = 0
    //
    // t = -Ro.z / Rd.z
    //

    // Can we hit the light from both sides?
    if (localRayDirection.z > 0 && m_sides == 1)
    {
        return false;
    }

    // If ray is parallel to plane of light, no intersection
    if (localRayDirection.z == 0)
    {
        return false;
    }

    // Distance to hit (in local space)
    RtFloat t = -localRayOrigin.z / localRayDirection.z;

    // Intersection point
    RtPoint3 localP = localRayOrigin + t * localRayDirection;

    // Test to see if point lies in -.5 -> .5 region around origin.
    if ((localP.x < -.5) || (localP.x > .5) || 
        (localP.y < -.5) || (localP.y > .5))
    {
        return false;
    }

    RtPoint3 currentP = localToCurrent->pTransform(localP);

    // Get distance in current space (instead of t)
    RtFloat d = (currentP - rayOrigin).Length();
    // Use 'biased' maxHitDistance
    if( d > maxHitDistance )
    {
        return false;
    }

    // outputs
    u = localP.x + .5;
    v = localP.y + .5;
    w = 0.f;

    hitP = currentP;

    hitNn = RtNormal3(0.f, 0.f, 1.f);
    hitNn = localToCurrent->vTransform(hitNn);
    hitNn.Normalize();

    hitDistance = d;

    return true;
}

RtFloat
PxrSimpleRectLight::GetPower() const
{
    return 1.0f;
}

RtFloat
PxrSimpleRectLight::GetSolidAngleEstimate(
    RtInt const nPoints,
    RtPoint3 const* pP,
    RtVector3 const* pN,
    RtFloat* pOutSolidAngles
) const
{
    return 0.0f;
}

RtFloat
PxrSimpleRectLight::GetIncidentRadianceEstimate(
        RtPoint3 const& segmentOrigin,
        RtVector3 const& segmentDir,
        RtFloat segmentLen,
        RtMatrix4x4 const& lightToCurrent,
        RtMatrix4x4 const& currentToLight,
        RtFloat& minT,
        RtFloat& maxT) const
{
    LightBasis lb;
    lb.Init(lightToCurrent);

    RtFloat r = m_color.ChannelAvg() * m_intensity * m_meanTexVal;
        RtVector3 direction = segmentDir;
        RtFloat distance = direction.Normalize(); // normalize + return length
        RtFloat dirDotLightN = direction.Dot(lb.Nn);
        if ((m_sides == 1) && (dirDotLightN > 0.0f)) 
        {
            return 0.0f;
        }
        else
        {
            RtFloat angularAtten = 1.0f;
            return angularAtten * r * lb.area * 
                fabs(dirDotLightN) / (distance * distance);
        }
}

RtFloat
PxrSimpleRectLight::GetIncidentRadianceEstimate(
    RtPoint3 const& P,
    RtMatrix4x4 const& lightToCurrent,
    RtMatrix4x4 const& currentToLight
    ) const
{

    LightBasis lb;
    lb.Init(lightToCurrent);

    static const RtFloat minCosTheta = 0.1f;

    RtFloat const lightR = std::max(lb.width, lb.height);
    RtFloat const lightR2 = lightR * lightR;
    RtFloat r = P.x*P.x + P.y*P.y;
    RtFloat const r2 = r * r;

    RtVector3 direction = lb.position - P;
    RtFloat const distance = direction.Normalize(); // normalize + return length
    RtFloat d2 = distance * distance;
    bool const doCos = d2 > lightR2 && d2 > r2;
    bool const checkFacing = (m_sides == 1) && doCos;

    // Mean of cos theta integrated over the hemisphere
    RtFloat maxCosTheta = 0.637f;
    if (doCos) {
        RtFloat const dirDotLightN = direction.Dot(lb.Nn);
        RtFloat const cosTheta = -dirDotLightN;
        RtFloat const sinTheta2 = 1.0f - cosTheta*cosTheta;
        // Compute the angular divergence at the edges of the sphere
        // We're constructing a right-angled triangle with the base
        // being the vector from the light to the sphere center, with
        // the sphere radius being another side at right angles from the center,
        // and the hypotenuse from the tip of this radius back to
        // the light. The angle between base and hypotenuse, phi,
        // is the amount by which the angle theta between base
        // and light normal can vary across the sphere
        RtFloat const tanPhi2 = r2 / d2;
        RtFloat const cosPhi2 = 1.0f / (1.0f + tanPhi2);
        RtFloat const sinPhi2 = 1.0f - cosPhi2;
        RtFloat const cosPhi = sqrtf(cosPhi2);
        // Cosine of the sums and differences of theta and phi
        RtFloat const sinThetaSinPhi = sqrtf(std::max(0.0f, sinTheta2 * sinPhi2));
        // RtFloat const cosA = cosTheta * cosPhi - sinThetaSinPhi;
        RtFloat const cosB = cosTheta * cosPhi + sinThetaSinPhi;
        // maxCosTheta = std::max(cosA, cosB);
        // NB sin terms are always positive, so the maximum
        // cos term is always obtained by subtracting phi from theta
        // (which is to say summing the cos and sin products above)
        maxCosTheta = cosB;

        // Is light facing away from the entire cluster
        if (checkFacing && maxCosTheta <= 0.0f) return 0.0f;

        maxCosTheta = std::max(fabsf(maxCosTheta), minCosTheta);
    }

    // Convert to solid angle measure
    // totalPower is emissivity x area
    // We want to clamp r against a multiple
    // of the sum of the cluster radius and
    // the light radius. Since we're dealing
    // with r^2, we want (a+b)^2 for sum
    // of cluster and light. Light radius
    // is apporximated as quarter of light area
    // (a+b)^2 = a^2 + b^2 + 2ab.
    RtFloat clampR2 = lightR2 + r2 + (2.0f * lightR * r);
    clampR2 *= 4.0f;
    d2 = std::max(d2, clampR2);

    RtFloat omega = lb.area * maxCosTheta / d2;
    return m_color.ChannelAvg() * m_intensity * m_meanTexVal * omega;

  
}

RtFloat
PxrSimpleRectLight::GetPowerEstimate(RtMatrix4x4 const& xform) const
{
    LightBasis lb;
    lb.Init(xform);
    return m_color.ChannelAvg() * m_intensity * m_meanTexVal * lb.area;
}

static RtFloat
equiangularSample(
    LightBasis const* lb,
    RtPoint3 const& P, 
    RtFloat2 const& xi, 
    RtPoint3& Pl, 
    RtFloat2& outXi)
{
    RtVector3 const lightCenterDir = lb->position - P;
    float subdist = Dot( lb->Nn, lightCenterDir); // (opposite of) distance from surfacePt to plane of light
    if( subdist >= 0.f )
    {
        return 0.f;
    }

    RtVector3 const _base = lb->position - 0.5f * (lb->uExtent + lb->vExtent);

    // Angle based sampling ("almost" solid angle)
    RtVector3 const W1  = lightCenterDir - 0.5f * lb->uExtent;
    RtVector3 const W2  = W1 + lb->uExtent;
    RtVector3 const H1  = lightCenterDir - 0.5f * lb->vExtent;
    RtVector3 const H2  = H1 + lb->vExtent;

    RtFloat const LW1_2 = Dot( W1 , W1 );
    RtFloat const LW2_2 = Dot( W2 , W2 );
    RtFloat const LW1   = sqrtf( LW1_2 );
    RtFloat const LW2   = sqrtf( LW2_2 );
    RtFloat const LH1_2 = Dot( H1 , H1 );
    RtFloat const LH2_2 = Dot( H2 , H2 );
    RtFloat const LH1   = sqrtf( LH1_2 );
    RtFloat const LH2   = sqrtf( LH2_2 );

    RtFloat areaPdf = 1.0f;

    if (LW1 > 1e-6 && LH1 > 1e-6f)
    {
        RtFloat const iLW1  = 1.f / LW1;
        RtFloat const iLW2  = 1.f / LW2;
        RtFloat const iLH1  = 1.f / LH1;
        RtFloat const iLH2  = 1.f / LH2;

        RtFloat const cosX = -iLW1 * Dot(W1, lb->Un);
        RtFloat const sinX = sqrtf(1.f - std::min(cosX*cosX, 1.f));
        RtFloat const cosY = -iLH1 * Dot(H1, lb->Vn);
        RtFloat const sinY = sqrtf(1.f - std::min(cosY*cosY, 1.f));

        if ( sinX == 0.f || sinY == 0.f)
        {
            return 0.f;
        }

        RtFloat const angW = acosf ( std::max( -1.f, std::min( 1.f, 
                        ( LW1_2 + LW2_2 - lb->width*lb->width) 
                        * 0.5f * iLW1 * iLW2 ) ) );
        RtFloat const angH = acosf( std::max( -1.f, std::min( 1.f, 
                        ( LH1_2 + LH2_2 - lb->height*lb->height ) 
                        * 0.5f * iLH1 * iLH2 ) ) );

        if ( angW == 0.f || angH == 0.f )
        {
            return 0.f;
        }

        RtFloat const tanW = tanf(angW * xi.x);
        RtFloat const tanH = tanf(angH * xi.y);

        RtFloat const projS = sinX + tanW * cosX;
        RtFloat const projT = sinY + tanH * cosY;
        RtFloat const ss = (tanW != 0.f) ? LW1 * tanW / projS : LW1;
        RtFloat const tt = (tanH != 0.f) ? LH1 * tanH / projT : LH1;

        outXi.x = ss / lb->Un.Dot(lb->uExtent);
        outXi.y = tt / lb->Vn.Dot(lb->vExtent);;

        // Position on the light
        Pl = _base + ss * lb->Un + tt * lb->Vn;

        RtFloat const pdfW = iLW1 * projS * projS / (angW * sinX * (1.f + tanW*tanW));
        RtFloat const pdfH = iLH1 * projT * projT / (angH * sinY * (1.f + tanH*tanH));

        areaPdf = pdfW * pdfH;

        assert(areaPdf > 0.0f && areaPdf < 1e16f);
    }
    else
    {
        outXi.x = xi.x;
        outXi.y = xi.y;

        Pl = _base + xi.x * lb->uExtent + xi.y * lb->vExtent;
        areaPdf = 1.0 / lb->area;
    }

    return areaPdf;
}

static RtFloat
equiangularEval(LightBasis const* lb, RtPoint3 const& P, RtFloat u, RtFloat v)
{
    RtVector3 const lightCenterDir = lb->position - P;
    float subdist = Dot( lb->Nn, lightCenterDir); // (opposite of) distance from surfacePt to plane of light
    if( subdist >= 0.f )
    {
        return 0.f;
    }

    // Angle based sampling ("almost" solid angle)
    RtVector3 const W1  = lightCenterDir - 0.5f * lb->uExtent;
    RtVector3 const W2  = W1 + lb->uExtent;
    RtVector3 const H1  = lightCenterDir - 0.5f * lb->vExtent;
    RtVector3 const H2  = H1 + lb->vExtent;

    RtFloat const LW1_2 = Dot(W1, W1);
    RtFloat const LW2_2 = Dot(W2, W2);
    RtFloat const LW1   = sqrtf(LW1_2);
    RtFloat const LW2   = sqrtf(LW2_2);
    RtFloat const LH1_2 = Dot(H1, H1);
    RtFloat const LH2_2 = Dot(H2, H2);
    RtFloat const LH1   = sqrtf(LH1_2);
    RtFloat const LH2   = sqrtf(LH2_2);

    RtFloat areaPdf = 1.0f;

    if (LW1 > 1e-6 && LH1 > 1e-6)
    {
        RtFloat const iLW1  = 1.f / LW1;
        RtFloat const iLW2  = 1.f / LW2;
        RtFloat const iLH1  = 1.f / LH1;
        RtFloat const iLH2  = 1.f / LH2;

        RtFloat const cosX = -iLW1 * Dot(W1, lb->Un);
        RtFloat const sinX = sqrtf(1.f - std::min(cosX*cosX, 1.f));
        RtFloat const cosY = -iLH1 * Dot(H1, lb->Vn);
        RtFloat const sinY = sqrtf(1.f - std::min(cosY*cosY, 1.f));

        if (sinX == 0.f || sinY == 0.f) 
        {
            return 0.f;
        }

        RtFloat angW = acosf(std::max(-1.0f, std::min(1.f, (LW1_2 + LW2_2 - lb->width * lb->width) * 0.5f * iLW1 * iLW2))); // law of cosines
        RtFloat angH = acosf(std::max(-1.0f, std::min(1.f, (LH1_2 + LH2_2 - lb->height * lb->height) * 0.5f * iLH1 * iLH2)));

        if (angW == 0.f || angH == 0.f)
        {
            return 0.f;
        }

        RtFloat const d1 = (LW1 - u * cosX);
        RtFloat const d2 = (LH1 - v * cosY);

        if (fabsf(d1) < 1e-16f || fabsf(d2) < 1e-16f)
        {
            return 0.f;
        }

        RtFloat const tanW = u * sinX / d1;
        RtFloat const tanH = v * sinY / d2;

        RtFloat const projS = sinX + tanW * cosX;
        RtFloat const projT = sinY + tanH * cosY;

        RtFloat const pdfW = iLW1 * projS * projS / (angW * sinX * (1.f + tanW * tanW));
        RtFloat const pdfH = iLH1 * projT * projT / (angH * sinY * (1.f + tanH * tanH));

        areaPdf = pdfW * pdfH;

        if (areaPdf <= 0.0f || areaPdf >= 1e16f)
        {
#ifndef NDEBUG
            fprintf(stderr, "pdfW: %g pdfH: %g\n", pdfW, pdfH);
#endif
            areaPdf = 0.0f;
        }
    }
    else
    {
        areaPdf = 1.0f / lb->area;
    }

    return areaPdf;
}

void
PxrSimpleRectLight::GenerateSamples(
    RixLightContext const& qc, RixScatterPoint const& scatter, GenerateSamplesResults &qr) const
{
    LightBasis const* lb;
    LightBasis motionBlurBasis;

    RtMatrix4x4 tmp;
    qc.GetLightToCurrentTransform(qc.GetTime(), tmp);
    motionBlurBasis.Init(tmp);
    lb = &motionBlurBasis;

    // Generating the sample in local space
    RtFloat2 sample2D = qc.GetSample2D();
    RtPoint3 const& P = scatter.scatterP; 

    RtFloat pdf = 1.0f;
    RtFloat3 currentSample(0.f);
    if (m_useEquiangularSampling)
    {
        pdf = equiangularSample(lb, P, sample2D, currentSample, sample2D);
    }
    else
    {
        RtPoint3 localSample = RtPoint3(sample2D.x - 0.5f, sample2D.y - 0.5f, 0.0f);
        currentSample = lb->xform.pTransform(localSample);
        pdf *= 1.0f / lb->area;
    }
    RtColorRGB textureValue(1.0);
    if(!m_colorMap.isNull()) textureValue = getColorMapValue(RtFloat2(currentSample.x,currentSample.y));

    RtVector3 direction = currentSample - P;
    RtFloat distance = direction.Normalize(); // normalize + return length
    RtFloat dirDotLightN = direction.Dot(lb->Nn);
    pdf *= (distance * distance) / fabs(dirDotLightN);

    RtColorRGB color;
    // equiangular sampligng returns a -ve pdf if light edge-on to shade point
    if (pdf > 0.0f && (dirDotLightN < 0 || m_sides == 2))
    {
        color = m_intensity * m_color * textureValue;
    }
    else
    {
        color = RtColorRGB(0.0f);
        pdf = 0.0f;
    }

    qr.UVW = RtFloat3(sample2D.x, sample2D.y, 0.f);
    qr.direction = direction;
    qr.distance = distance;
    qr.diffuseColor = color;
    qr.specularColor = color;
    qr.pdfDirect = pdf;
}

void
PxrSimpleRectLight::EvaluateSamples(
    RixLightContext const& qc, 
    RixSamplePoint const& sample,
    RixScatterPoint const& scatter,
    EvaluateSamplesResults &qr) const
{
    LightBasis const* lb;
    LightBasis motionBlurBasis;

    RtMatrix4x4 tmp;
    qc.GetLightToCurrentTransform(qc.GetTime(), tmp);
    motionBlurBasis.Init(tmp);
    lb = &motionBlurBasis;

    // Find point on light
    RtVector3 const direction = sample.direction; 
    RtFloat const distance = sample.distance; 
    RtFloat3 const uvw = sample.uvw; 

    RtFloat dirDotLightN = direction.Dot( lb->Nn );

    RtFloat pdf = (distance * distance) / (fabsf(dirDotLightN));
    if (m_useEquiangularSampling)
    {
        RtPoint3 const& P = scatter.scatterP; 
        pdf *= equiangularEval(lb, P, uvw.x, uvw.y);
    }
    else
    {
        pdf /= lb->area;
    }

    RtColorRGB textureValue(1.0);
    if(!m_colorMap.isNull()) textureValue = getColorMapValue(RtFloat2(uvw.x,uvw.y));

    RtColorRGB color;
    if (dirDotLightN < 0.f || m_sides == 2)
    {
        color = m_intensity * m_color * textureValue;
    }
    else
    {
        color = RtColorRGB(0.f);
        pdf = 0.0f;
    }

    qr.diffuseColor = color;
    qr.specularColor = color;
    qr.pdfDirect = pdf;
}

void
PxrSimpleRectLight::GenerateEmission( 
    RixLightContext const& qc, 
    GenerateEmissionResults &qr) const
{
    RixPhotonGuiding const* photonGuiding = qc.GetPhotonGuiding();
    bool usePhotonGuiding = (photonGuiding && photonGuiding->samplingPdf() != 0.0f);

    LightBasis lb;
    RtMatrix4x4 tmp;
    qc.GetLightToCurrentTransform(qc.GetTime(), tmp);
    lb.Init(tmp);

    // Generating the sample in local space
    RtFloat2 sample2D = qc.GetSample2D(); 
    RtPoint3 localPosition = RtPoint3(sample2D.x - 0.5f, sample2D.y - 0.5f, 0.0f);
    RtPoint3 photonPosition = lb.xform.pTransform(localPosition);

    // probability of emitting a photon at that position, area measure
    RtFloat pdfEmitA = 1.f / lb.area;

    // direction of the emitted photon
    RtFloat cosTheta;
    RtVector3 photonDirection;

#ifdef WIN32
    RtFloat2 tmpRandom( (rand() / (RAND_MAX + 1.0)),  (rand() / (RAND_MAX + 1.0))); //Allegedly mimics drand48
#else
    RtFloat2 tmpRandom(drand48(), drand48());
#endif

    RtFloat pdfEmitDirection = 0.0f;

    if (usePhotonGuiding 
        && photonGuiding->canSample(photonPosition, lb.Nn, m_sides == 1)
    )
    {
        RixPhotonGuiding::BoundingBoxProjection bbProjection(photonGuiding);
        bbProjection.computeProjection(photonPosition);
        if (photonGuiding->pickPhotonGuiding(tmpRandom.y))
        {
            RtFloat photonPdf;
            photonGuiding->sampleDirection(
                photonPosition,
                lb.Nn,
                bbProjection,
                tmpRandom.x, tmpRandom.y,
                photonDirection, cosTheta, photonPdf);

            RtFloat cosineDistributionPdf =
                (photonDirection.Dot(lb.Nn) > 0.0) ?
                cosTheta / RtFloat(F_PI):
                0.0f;

            pdfEmitDirection = photonGuiding->MISAreaLightPdf(
                photonPosition, lb.Nn, 
                photonDirection, m_sides == 1, cosineDistributionPdf);
        }
        else
        {
            RixCosDirectionalDistribution(
                tmpRandom, lb.Nn, lb.Un, lb.Vn, 
                photonDirection, cosTheta);

            RtFloat cosineDistributionPdf = cosTheta / RtFloat(F_PI);

            pdfEmitDirection = photonGuiding->MISAreaLightPdf(
                photonPosition, lb.Nn, photonDirection,
                m_sides == 1, cosineDistributionPdf);
        }
    }
    else
    {
        RixCosDirectionalDistribution(
            tmpRandom, lb.Nn, lb.Un, lb.Vn, 
            photonDirection, cosTheta);
        photonDirection.Normalize(); 

        // probability of emitting a photon in this particular direction
        pdfEmitDirection = cosTheta / RtFloat(F_PI);
    }

    RtFloat photonDistance = 1e20; 

    RtColorRGB color = RtColorRGB(m_intensity);

    if (photonDirection.Dot(lb.Nn) < 0.0f)
    {
        color = RtColorRGB(0.0f);
    }

    qr.UVW = RtFloat3(sample2D.x, sample2D.y, 0.f);
    qr.position = photonPosition;
    qr.direction = photonDirection;
    qr.distance = photonDistance;
    qr.normal = lb.Nn;
    qr.pdfEmit = pdfEmitA;
    qr.pdfEmitDirection = pdfEmitDirection;
}

void 
PxrSimpleRectLight::EvaluateEmissionForCamera(
        RixLightContext const& qc,
        RixSamplePoint const& sample,
        RixScatterPoint const& scatter,
        EvaluateEmissionForCameraResults& results) const
{
    LightBasis const* lb;
    LightBasis motionBlurBasis;

    RtMatrix4x4 tmp;
    qc.GetLightToCurrentTransform(qc.GetTime(), tmp);
    motionBlurBasis.Init(tmp);
    lb = &motionBlurBasis;

    // Find point on light
    RtVector3 const direction = sample.direction; 
    RtFloat const distance = sample.distance; 
    RtFloat3 const uvw = sample.uvw; 

    RtFloat dirDotLightN = direction.Dot( lb->Nn );

    RtFloat pdf = (distance * distance) / (fabsf(dirDotLightN));
    if (m_useEquiangularSampling)
    {
        RtPoint3 const& P = scatter.scatterP; 
        pdf *= equiangularEval(lb, P, uvw.x, uvw.y);
    }
    else
    {
        pdf /= lb->area;
    }

    RtColorRGB textureValue(1.0);
    if(!m_colorMap.isNull()) textureValue = getColorMapValue(RtFloat2(uvw.x,uvw.y));

    RtColorRGB color;
    if (dirDotLightN < 0.f || m_sides == 2)
    {
        color = m_intensity * m_color * textureValue;
    }
    else
    {
        color = RtColorRGB(0.f);
        pdf = 0.0f;
    }

    results.cameraColor = color; 
}

struct InstanceDataStruct
{
public:
    RtColorRGB color;
    QImage colorMap;
    RtFloat exposure;
    RtFloat intensity;
    RtConstString lightGroup;
    RtInt sides;
    RtInt useEquiangularSampling;

    InstanceDataStruct(
        RtColorRGB _color,
        QImage _colorMap,
        RtFloat _exposure,
        RtFloat _intensity, 
        RtConstString _lightGroup,
        RtInt _sides,
        RtInt _useEquiangularSampling)
    {
        color = _color;
        colorMap = _colorMap;
        exposure = _exposure;
        intensity = _intensity;
        lightGroup = _lightGroup;
        sides = _sides;
        useEquiangularSampling = _useEquiangularSampling;
    }
};

static void freeInstanceDataStruct(RtPointer data)
{
    delete ((InstanceDataStruct*)data);
}

RixLight* 
PxrSimpleRectLight::Edit(
        RixContext& ctx,
        RixParameterList const* pList,
        RtConstPointer instanceData)
{
    InstanceDataStruct *data = (InstanceDataStruct*)instanceData;
    RtInt paramId;
    RtInt error;

    error = pList->GetParamId("intensity", &paramId);
    if (error == 0) pList->EvalParam(paramId, 0, &data->intensity);

    error = pList->GetParamId("exposure", &paramId);
    if (error == 0) pList->EvalParam(paramId, 0, &data->exposure);

    error = pList->GetParamId("lightColor", &paramId);
    if (error == 0) pList->EvalParam(paramId, 0, &data->color);

    error = pList->GetParamId("lightColorMap", &paramId);
    if(error ==0)
    {
        RtConstString fileName = NULL;
        pList->EvalParam(paramId, 0, &fileName);
        QImage i(fileName);
        if(!i.isNull())
        {
            data->colorMap = i;
        }
    }

    error = pList->GetParamId("sides", &paramId);
    if (error == 0) pList->EvalParam(paramId, 0, &data->sides);

    error = pList->GetParamId("useEquiangularSampling", &paramId);
    if (error == 0) pList->EvalParam(paramId, 0, &data->useEquiangularSampling);

    RtInt enableTemperature = 0;
    error = pList->GetParamId("enableTemperature", &paramId);
    if (error == 0) pList->EvalParam(paramId, 0, &enableTemperature);

    RtFloat temperature = 0.0f;
    error = pList->GetParamId("temperature", &paramId);
    if (error == 0) pList->EvalParam(paramId, 0, &temperature);

    if (enableTemperature)
        data->color *= RixKtoRGB(temperature, ctx);

    m_intensity = data->intensity;
    m_intensity *= powf(2.0, data->exposure);
    m_sides = data->sides;
    m_useEquiangularSampling = data->useEquiangularSampling != 0;
    m_color = data->color;

    return this; 
}

RtColorRGB PxrSimpleRectLight::getColorMapValue(RtFloat2 _uv) const
{
    RtFloat2 np = _uv;
    np.y = 1.f-np.y;
    if(np.x<0.f || np.x>1.f || np.y<0.f || np.y>1.f)
    {
        printf("out of bounds %f,%f\n",_uv.x,_uv.y);
        return RtColorRGB(0.f);
    }

    // get our 4 surrounding pixel corrdinates
    RtFloat2 mmin,mmax;
    np.x*=m_colorMap.width()-1;
    np.y*=m_colorMap.height()-1;
    RtFloat2 npf;
    npf.x= floorf(np.x);
    npf.y= floorf(np.y);
    if(np.x-npf.x>0.5f)
    {
       mmin.x = (int)npf.x;
       mmax.x = mmin.x+1;
    }
    else
    {
        mmax.x = (int)npf.x;
        mmin.x = mmax.x-1;
    }
    if(np.y-npf.y>0.5f)
    {
       mmin.y = (int)npf.y;
       mmax.y = mmin.y+1;
    }
    else
    {
        mmax.y = (int)npf.y;
        mmin.y = mmax.y-1;
    }
    mmin = clamp(mmin,RtFloat2(0,0),RtFloat2(m_colorMap.width()-1,m_colorMap.height()-1));
    mmax = clamp(mmax,RtFloat2(0,0),RtFloat2(m_colorMap.width()-1,m_colorMap.height()-1));

    RtFloat3 Q11 = getPixelValue(RtFloat2(mmin.x , mmin.y));
    RtFloat3 Q12 = getPixelValue(RtFloat2(mmax.x , mmin.y));
    RtFloat3 Q21 = getPixelValue(RtFloat2(mmin.x , mmax.y));
    RtFloat3 Q22 = getPixelValue(RtFloat2(mmax.x , mmax.y));

    RtFloat3 fx1 = lerp(Q11,Q12,np.x-mmin.x);
    RtFloat3 fx2 = lerp(Q21,Q22,np.x-mmin.x);

    //return clamp(_buff[(int)np.x + (int)(np.y*props.outRes.x)]*10.f,0.f,1.f);
    RtFloat3 result = clamp(lerp(fx1,fx2,np.y-mmin.y),RtFloat3(0.f),RtFloat3(1.f));

    return RtColorRGB(result.x,result.y,result.z);
}

RtFloat3 PxrSimpleRectLight::getPixelValue(RtFloat2 _x) const
{
    QColor c = QColor(m_colorMap.pixel((int)_x.x,(int)_x.y));
    return RtFloat3(c.redF(),c.greenF(),c.blueF());
}


class PxrSimpleRectLightFactory : public RixLightFactory
{
public:
    PxrSimpleRectLightFactory() {};

    virtual RtInt Init(RixContext& ctx, char const* pluginPath)
    {
        return 0;
    }

    virtual void Finalize(RixContext &ctx)
    {}

    virtual RixSCParamInfo const *GetParamTable();

    virtual RtInt CreateInstanceData(
        RixContext & rixCtx,
        char const* handle,
        RixParameterList const* pList,
        InstanceData* result)
    {
        // retrieving uniform parameters
        RtInt paramId;
        RtInt error;

        InstanceDataStruct* data = new InstanceDataStruct(
            RtColorRGB(1.f, 1.f, 1.f),  // color
            QImage(),                   // colorMap
            0.f,                        // exposure
            1.f,                        // intensity
            "",                         // lightGroup
            2 ,                         // sides
            1                          // useEquiangularSampling
        );

        error = pList->GetParamId("intensity", &paramId);
        if (error == 0) pList->EvalParam(paramId, 0, &data->intensity);

        error = pList->GetParamId("exposure", &paramId);
        if (error == 0) pList->EvalParam(paramId, 0, &data->exposure);

        error = pList->GetParamId("lightColor", &paramId);
        if (error == 0) pList->EvalParam(paramId, 0, &data->color);

        RixMessages *messagesHandle = (RixMessages *) rixCtx.GetRixInterface(k_RixMessages);
        messagesHandle->Warning("Loading Image\n");

        error = pList->GetParamId("lightColorMap", &paramId);
        if(error == 0)
        {
            messagesHandle->Warning("Got Param id");
            RtConstString fileName = NULL;
            pList->EvalParam(paramId, -1, &fileName);
            messagesHandle->Warning("Got file name %s",fileName);
            QImage i(fileName);
            if(!i.isNull())
            {
                data->colorMap = i;
                messagesHandle->Warning("Image Loaded");
            }
            else
            {
                messagesHandle->Warning("Image failed to load");
            }
        }

        error = pList->GetParamId("lightGroup", &paramId);
        if (error == 0) pList->EvalParam(paramId, 0, &data->lightGroup);

        error = pList->GetParamId("sides", &paramId);
        if (error == 0) pList->EvalParam(paramId, 0, &data->sides);

        // misc
        error = pList->GetParamId("useEquiangularSampling", &paramId);
        if (error == 0) pList->EvalParam(paramId, 0, &data->useEquiangularSampling);

        RtInt enableTemperature = 0;
        error = pList->GetParamId("enableTemperature", &paramId);
        if (error == 0) pList->EvalParam(paramId, 0, &enableTemperature);

        RtFloat temperature = 0.0f;
        error = pList->GetParamId("temperature", &paramId);
        if (error == 0) pList->EvalParam(paramId, 0, &temperature);

        if (enableTemperature)
            data->color *= RixKtoRGB(temperature, rixCtx);

        result->data = (void*)data;
        result->datalen = sizeof(InstanceDataStruct);
        result->freefunc = freeInstanceDataStruct; 

        return 0;
    }

    virtual RixLight* CreateLight(
        RixContext & rixCtx,
        RixParameterList const* pList,
        RtConstPointer instancedata)
    {
        InstanceDataStruct const* data = (InstanceDataStruct const*)instancedata;
        return new PxrSimpleRectLight(
            this,
            RixLight::k_RixLocal,
            data->exposure,
            data->intensity, 
            data->color, 
            data->colorMap,
            data->lightGroup,
            data->sides,
            data->useEquiangularSampling != 0);
    }

    virtual void DestroyLight(RixLight const *light)
    {
        delete static_cast<PxrSimpleRectLight const*>(light);
    }
};

enum paramIds
{
    k_lightColor,
    k_lightColorMap,
    k_exposure,
    k_intensity,
    k_enableTemperature,
    k_temperature,
    k___group,
    k_sides,
    k_useEquiangularSampling,
};

RixSCParamInfo const *
PxrSimpleRectLightFactory::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        // Inputs
        RixSCParamInfo("lightColor", k_RixSCColor),
        RixSCParamInfo("lightColorMap", k_RixSCString),
        RixSCParamInfo("exposure", k_RixSCFloat),
        RixSCParamInfo("intensity", k_RixSCFloat),
        RixSCParamInfo("enableTemperature", k_RixSCInteger),
        RixSCParamInfo("temperature", k_RixSCFloat),
        RixSCParamInfo("lightGroup", k_RixSCString),
        RixSCParamInfo("sides", k_RixSCInteger),
        RixSCParamInfo("useEquiangularSampling", k_RixSCInteger),

        // End
        RixSCParamInfo()
    };

    return &s_ptable[0];
};

extern "C" PRMANEXPORT RixLightFactory* CreateRixLightFactory(const char* hint)
{
    return new PxrSimpleRectLightFactory();
}

extern "C" PRMANEXPORT void DestroyRixLightFactory(RixLightFactory* factory)
{
    delete (PxrSimpleRectLightFactory*)factory;
}
